package adapters

import (
	"fmt"
	common "github.com/scanoss/papi/api/commonv2"
	"testing"

	_ "github.com/mattn/go-sqlite3"
	pb "github.com/scanoss/papi/api/vulnerabilitiesv2"
	zlog "github.com/scanoss/zap-logging-helper/pkg/logger"

	"scanoss.com/vulnerabilities/pkg/dtos"
)

func TestVulnOutputToVulnerabilityResponse(t *testing.T) {
	err := zlog.NewSugaredDevLogger()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a sugared logger", err)
	}
	defer zlog.SyncZap()

	tests := []struct {
		input         dtos.VulnerabilityOutput
		expectError   bool
		expectedCount int
		name          string
	}{
		{
			input: dtos.VulnerabilityOutput{
				Components: []dtos.VulnerabilityComponentOutput{
					{
						Purl:            "pkg:github/scanoss/scanoss.js",
						Requirement:     ">=0.16.0",
						Version:         "0.17:0",
						Vulnerabilities: make([]dtos.VulnerabilitiesOutput, 0),
					},
				},
			},
			expectedCount: 1,
			expectError:   false,
			name:          "Empty components",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			_, err := FromVulnerabilityOutputToVulnerabilityResponse(tt.input)
			if tt.expectError && err == nil {
				t.Error("expected error but got none")
			}
		})
	}
}

func TestFromCpeComponentOutputTOCpeResponse(t *testing.T) {
	err := zlog.NewSugaredDevLogger()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a sugared logger", err)
	}
	defer zlog.SyncZap()
	tests := []struct {
		name          string
		input         []dtos.CpeComponentOutput
		expectedError bool
	}{
		{
			name: "Valid input",
			input: []dtos.CpeComponentOutput{
				{
					Purl:        "pkg:github/scanoss/scanoss.js",
					Version:     "0.17:0",
					Requirement: ">=0.16.0",
					Cpes:        []string{"cpe:2.3:a:scanoss:scanoss.js:0.17:*:*:*:*:*:*:*"},
				},
			},
			expectedError: false,
		},
		{
			name:          "Valid input empty components",
			input:         []dtos.CpeComponentOutput{},
			expectedError: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			resp, err := FromCpeComponentOutputTOCpeResponse(tt.input)
			if err != nil {
				t.Errorf("TestCpeOutputConvert failed: %v", err)
			}
			fmt.Printf("Output: %v\n", resp)
		})
	}

}

func TestVulnerabilityRequestToComponentDTO(t *testing.T) {
	err := zlog.NewSugaredDevLogger()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a sugared logger", err)
	}
	defer zlog.SyncZap()
	tests := []struct {
		input             *pb.VulnerabilityRequest
		expectError       bool
		name              string
		validComponents   []dtos.ComponentDTO
		invalidComponents []dtos.ComponentDTO
	}{
		{
			input:             &pb.VulnerabilityRequest{},
			expectError:       true,
			name:              "Empty request",
			validComponents:   []dtos.ComponentDTO{},
			invalidComponents: []dtos.ComponentDTO{},
		},
		{
			input: &pb.VulnerabilityRequest{Purls: []*pb.VulnerabilityRequest_Purls{
				{
					Purl: "g:golang/example@1.0.0",
				},
				{
					Purl: "pkg:github/lodash@4.17.21",
				},
			}},
			expectError: false,
			name:        "Valid request",
			validComponents: []dtos.ComponentDTO{
				{
					Purl: "pkg:github/lodash@4.17.21",
				},
			},
			invalidComponents: []dtos.ComponentDTO{
				{
					Purl: "g:golang/example@1.0.0",
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {

			components, invalidComponents, err := FromVulnerabilityRequestToComponentDTO(tt.input)

			if tt.expectError && err == nil {
				t.Error("expected error but got none")
			}
			if !tt.expectError && err != nil {
				t.Errorf("unexpected error: %v", err)
			}

			if len(components) != len(tt.validComponents) {
				t.Errorf("expected %d components but got %d", len(tt.validComponents), len(components))
			}
			if len(invalidComponents) != len(tt.invalidComponents) {
				t.Errorf("expected %d invalid components but got %d", len(tt.invalidComponents), len(invalidComponents))
			}
		})
	}
}

func TestVulnerabilityOutputToComponentVulnerabilityResponse(t *testing.T) {
	err := zlog.NewSugaredDevLogger()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a sugared logger", err)
	}
	defer zlog.SyncZap()
	input := dtos.VulnerabilityOutput{
		Components: []dtos.VulnerabilityComponentOutput{
			{
				Purl:            "pkg:github/scanoss/scanoss.js",
				Requirement:     ">=0.16.0",
				Version:         "0.17:0",
				Vulnerabilities: make([]dtos.VulnerabilitiesOutput, 0),
			},
		},
	}
	response, err := FromVulnerabilityOutputToComponentVulnerabilityResponse(input)
	if err != nil {
		t.Errorf("TestOutputConvert failed: %v", err)
	}
	if response.Component.Purl != input.Components[0].Purl {
		t.Errorf("Expected %s but got %s", input.Components[0].Purl, response.Component.Purl)
	}
	if response.Component.Requirement != input.Components[0].Requirement {
		t.Errorf("Expected %s but got %s", input.Components[0].Requirement, response.Component.Requirement)
	}
	if response.Component.Version != input.Components[0].Version {
		t.Errorf("Expected %s but got %s", input.Components[0].Version, response.Component.Version)
	}
}

func TestVulnerabilityOutputToComponentsVulnerabilityResponse(t *testing.T) {
	err := zlog.NewSugaredDevLogger()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a sugared logger", err)
	}
	defer zlog.SyncZap()

	tests := []struct {
		name          string
		input         dtos.VulnerabilityOutput
		expectError   bool
		expectedCount int
	}{
		{
			name: "Multiple components with empty vulnerabilities",
			input: dtos.VulnerabilityOutput{
				Components: []dtos.VulnerabilityComponentOutput{
					{
						Purl:            "pkg:github/scanoss/scanoss.js",
						Requirement:     ">=0.16.0",
						Version:         "0.17:0",
						Vulnerabilities: make([]dtos.VulnerabilitiesOutput, 0),
					},
					{
						Purl:            "pkg:github/scanoss/scanoss.py",
						Requirement:     ">=0.30.0",
						Version:         "0.31:0",
						Vulnerabilities: make([]dtos.VulnerabilitiesOutput, 0),
					},
				},
			},
			expectError:   false,
			expectedCount: 2,
		},
		{
			name: "Single component with vulnerabilities",
			input: dtos.VulnerabilityOutput{
				Components: []dtos.VulnerabilityComponentOutput{
					{
						Purl:        "pkg:npm/lodash@4.17.20",
						Requirement: "4.17.20",
						Version:     "4.17.20",
						Vulnerabilities: []dtos.VulnerabilitiesOutput{
							{
								ID:       "GHSA-35jh-r3h4-6jhm",
								Cve:      "CVE-2021-23337",
								URL:      "https://github.com/advisories/GHSA-35jh-r3h4-6jhm",
								Summary:  "Command injection vulnerability",
								Severity: "HIGH",
								Source:   "github",
							},
						},
					},
				},
			},
			expectError:   false,
			expectedCount: 1,
		},
		{
			name: "Empty components",
			input: dtos.VulnerabilityOutput{
				Components: []dtos.VulnerabilityComponentOutput{},
			},
			expectError:   false,
			expectedCount: 0,
		},
		{
			name: "Component with multiple vulnerabilities",
			input: dtos.VulnerabilityOutput{
				Components: []dtos.VulnerabilityComponentOutput{
					{
						Purl:        "pkg:maven/org.apache.struts/struts2-core@2.3.34",
						Requirement: "2.3.34",
						Version:     "2.3.34",
						Vulnerabilities: []dtos.VulnerabilitiesOutput{
							{
								ID:       "CVE-2017-5638",
								Cve:      "CVE-2017-5638",
								URL:      "https://nvd.nist.gov/vuln/detail/CVE-2017-5638",
								Summary:  "Remote code execution via content-type header",
								Severity: "CRITICAL",
								Source:   "nvd",
							},
							{
								ID:       "CVE-2017-9791",
								Cve:      "CVE-2017-9791",
								URL:      "https://nvd.nist.gov/vuln/detail/CVE-2017-9791",
								Summary:  "XSS vulnerability in Struts 1 plugin",
								Severity: "MEDIUM",
								Source:   "nvd",
							},
						},
					},
				},
			},
			expectError:   false,
			expectedCount: 1,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			response, err := FromVulnerabilityOutputToComponentsVulnerabilityResponse(tt.input)

			if tt.expectError && err == nil {
				t.Error("expected error but got none")
			}
			if !tt.expectError && err != nil {
				t.Errorf("unexpected error: %v", err)
			}

			if !tt.expectError {
				if response == nil {
					t.Fatal("expected response but got nil")
				}
				if len(response.Components) != tt.expectedCount {
					t.Errorf("expected %d components but got %d", tt.expectedCount, len(response.Components))
				}

				if tt.expectedCount > 0 && len(tt.input.Components) > 0 {

					for i, r := range response.Components {
						inputComponent := tt.input.Components[i]

						if r.Purl != inputComponent.Purl {
							t.Errorf("Expected purl %s but got %s", inputComponent.Purl, r.Purl)
						}
						if r.Requirement != inputComponent.Requirement {
							t.Errorf("Expected requirement %s but got %s", inputComponent.Requirement,
								r.Requirement)
						}
						if r.Version != inputComponent.Version {
							t.Errorf("Expected version %s but got %s", inputComponent.Version, r.Version)
						}
						if len(r.Vulnerabilities) != len(inputComponent.Vulnerabilities) {
							t.Errorf("Expected %d vulnerabilities but got %d",
								len(inputComponent.Vulnerabilities), len(r.Vulnerabilities))
						}
					}
				}
			}
		})
	}
}

func TestSanitizeComponents(t *testing.T) {
	tests := []struct {
		name               string
		components         []dtos.ComponentDTO
		expectedValid      int
		expectedInvalid    int
		expectedFirstValid dtos.ComponentDTO
	}{
		{
			name: "All valid components",
			components: []dtos.ComponentDTO{
				{Purl: "pkg:npm/lodash@4.17.21"},
				{Purl: "pkg:github/scanoss/scanoss.js@1.0.0"},
			},
			expectedValid:   2,
			expectedInvalid: 0,
		},
		{
			name: "Mixed valid and invalid components",
			components: []dtos.ComponentDTO{
				{Purl: "pkg:npm/lodash@4.17.21"},
				{Purl: "invalid-purl"},
			},
			expectedValid:   1,
			expectedInvalid: 1,
		},
		{
			name: "Component with empty requirement gets extracted from purl",
			components: []dtos.ComponentDTO{
				{Purl: "pkg:npm/lodash@4.17.21", Requirement: ""},
			},
			expectedValid:      1,
			expectedInvalid:    0,
			expectedFirstValid: dtos.ComponentDTO{Purl: "pkg:npm/lodash", Requirement: "4.17.21"},
		},
		{
			name:            "All invalid components",
			components:      []dtos.ComponentDTO{{Purl: "invalid"}, {Purl: "also-invalid"}},
			expectedValid:   0,
			expectedInvalid: 2,
		},
		{
			name:            "Empty components",
			components:      []dtos.ComponentDTO{},
			expectedValid:   0,
			expectedInvalid: 0,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			valid, invalid := sanitizeComponents(tt.components)

			if len(valid) != tt.expectedValid {
				t.Errorf("expected %d valid components but got %d", tt.expectedValid, len(valid))
			}
			if len(invalid) != tt.expectedInvalid {
				t.Errorf("expected %d invalid components but got %d", tt.expectedInvalid, len(invalid))
			}

			if tt.expectedValid > 0 && tt.expectedFirstValid.Purl != "" {
				if valid[0].Purl != tt.expectedFirstValid.Purl {
					t.Errorf("expected first valid purl %s but got %s", tt.expectedFirstValid.Purl, valid[0].Purl)
				}
				if valid[0].Requirement != tt.expectedFirstValid.Requirement {
					t.Errorf("expected first valid requirement %s but got %s", tt.expectedFirstValid.Requirement, valid[0].Requirement)
				}
			}
		})
	}
}

func TestFromComponentsRequestToComponentDTO(t *testing.T) {
	err := zlog.NewSugaredDevLogger()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a sugared logger", err)
	}
	defer zlog.SyncZap()

	tests := []struct {
		name                 string
		request              *common.ComponentsRequest
		expectedValidCount   int
		expectedInvalidCount int
		expectError          bool
	}{
		{
			name: "Valid components request",
			request: &common.ComponentsRequest{
				Components: []*common.ComponentRequest{
					{Purl: "pkg:npm/lodash@4.17.21"},
					{Purl: "pkg:github/scanoss/scanoss.js@1.0.0"},
				},
			},
			expectedValidCount:   2,
			expectedInvalidCount: 0,
			expectError:          false,
		},
		{
			name: "Mixed valid and invalid components",
			request: &common.ComponentsRequest{
				Components: []*common.ComponentRequest{
					{Purl: "pkg:npm/lodash@4.17.21"},
					{Purl: "invalid-purl"},
				},
			},
			expectedValidCount:   1,
			expectedInvalidCount: 1,
			expectError:          false,
		},
		{
			name: "Empty components request",
			request: &common.ComponentsRequest{
				Components: []*common.ComponentRequest{},
			},
			expectedValidCount:   0,
			expectedInvalidCount: 0,
			expectError:          false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			validComponents, invalidComponents, err := FromComponentsRequestToComponentDTO(tt.request)

			if tt.expectError && err == nil {
				t.Error("expected error but got none")
			}
			if !tt.expectError && err != nil {
				t.Errorf("unexpected error: %v", err)
			}

			if len(validComponents) != tt.expectedValidCount {
				t.Errorf("expected %d valid components but got %d", tt.expectedValidCount, len(validComponents))
			}
			if len(invalidComponents) != tt.expectedInvalidCount {
				t.Errorf("expected %d invalid components but got %d", tt.expectedInvalidCount, len(invalidComponents))
			}
		})
	}
}

func TestFromComponentRequestToComponentDTO(t *testing.T) {
	err := zlog.NewSugaredDevLogger()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a sugared logger", err)
	}
	defer zlog.SyncZap()

	tests := []struct {
		name        string
		request     *common.ComponentRequest
		expectError bool
	}{
		{
			name:        "Valid component request",
			request:     &common.ComponentRequest{Purl: "pkg:npm/lodash@4.17.21"},
			expectError: false,
		},
		{
			name:        "Invalid component request",
			request:     &common.ComponentRequest{Purl: "invalid-purl"},
			expectError: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			component, err := FromComponentRequestToComponentDTO(tt.request)

			if tt.expectError && err == nil {
				t.Error("expected error but got none")
			}
			if !tt.expectError && err != nil {
				t.Errorf("unexpected error: %v", err)
			}
			if !tt.expectError && component.Purl == "" {
				t.Error("expected valid component but got empty purl")
			}
		})
	}
}

func TestFromCpeComponentOutputToComponentCpesResponse(t *testing.T) {
	err := zlog.NewSugaredDevLogger()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a sugared logger", err)
	}
	defer zlog.SyncZap()

	tests := []struct {
		name        string
		input       []dtos.CpeComponentOutput
		expectError bool
	}{
		{
			name: "Valid CPE component output",
			input: []dtos.CpeComponentOutput{
				{
					Purl:        "pkg:npm/lodash@4.17.21",
					Version:     "4.17.21",
					Requirement: "4.17.21",
					Cpes:        []string{"cpe:2.3:a:lodash:lodash:4.17.21:*:*:*:*:*:*:*"},
				},
			},
			expectError: false,
		},
		{
			name:        "Empty CPE component output",
			input:       []dtos.CpeComponentOutput{},
			expectError: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			response, err := FromCpeComponentOutputToComponentCpesResponse(tt.input)

			if tt.expectError && err == nil {
				t.Error("expected error but got none")
			}
			if !tt.expectError && err != nil {
				t.Errorf("unexpected error: %v", err)
			}
			if !tt.expectError && response == nil {
				t.Error("expected valid response but got nil")
			}
		})
	}
}

func TestFromCpeComponentOutputToComponentsCpesResponse(t *testing.T) {
	err := zlog.NewSugaredDevLogger()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a sugared logger", err)
	}
	defer zlog.SyncZap()

	tests := []struct {
		name              string
		input             []dtos.CpeComponentOutput
		expectError       bool
		expectedCompCount int
	}{
		{
			name: "Valid CPE components output",
			input: []dtos.CpeComponentOutput{
				{
					Purl:        "pkg:npm/lodash@4.17.21",
					Version:     "4.17.21",
					Requirement: "4.17.21",
					Cpes:        []string{"cpe:2.3:a:lodash:lodash:4.17.21:*:*:*:*:*:*:*"},
				},
				{
					Purl:        "pkg:npm/express@4.18.2",
					Version:     "4.18.2",
					Requirement: "4.18.2",
					Cpes:        []string{"cpe:2.3:a:expressjs:express:4.18.2:*:*:*:*:*:*:*"},
				},
			},
			expectError:       false,
			expectedCompCount: 2,
		},
		{
			name:              "Empty CPE components output",
			input:             []dtos.CpeComponentOutput{},
			expectError:       false,
			expectedCompCount: 0,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			response, err := FromCpeComponentOutputToComponentsCpesResponse(tt.input)

			if tt.expectError && err == nil {
				t.Error("expected error but got none")
			}
			if !tt.expectError && err != nil {
				t.Errorf("unexpected error: %v", err)
			}
			if !tt.expectError {
				if response == nil {
					t.Error("expected valid response but got nil")
				} else if len(response.Components) != tt.expectedCompCount {
					t.Errorf("expected %d components but got %d", tt.expectedCompCount, len(response.Components))
				}
			}
		})
	}
}

func TestGetComponentCPEInfo(t *testing.T) {
	tests := []struct {
		name              string
		input             []dtos.CpeComponentOutput
		expectError       bool
		expectedCompCount int
	}{
		{
			name: "Valid CPE component output",
			input: []dtos.CpeComponentOutput{
				{
					Purl:        "pkg:npm/lodash@4.17.21",
					Version:     "4.17.21",
					Requirement: "4.17.21",
					Cpes:        []string{"cpe:2.3:a:lodash:lodash:4.17.21:*:*:*:*:*:*:*"},
				},
			},
			expectError:       false,
			expectedCompCount: 1,
		},
		{
			name:              "Empty CPE component output",
			input:             []dtos.CpeComponentOutput{},
			expectError:       false,
			expectedCompCount: 0,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			componentsInfo, err := getComponentCPEInfo(tt.input)

			if tt.expectError && err == nil {
				t.Error("expected error but got none")
			}
			if !tt.expectError && err != nil {
				t.Errorf("unexpected error: %v", err)
			}
			if !tt.expectError && len(componentsInfo) != tt.expectedCompCount {
				t.Errorf("expected %d components but got %d", tt.expectedCompCount, len(componentsInfo))
			}
		})
	}
}

func TestGetComponentVulnerabilityInfo(t *testing.T) {
	tests := []struct {
		name              string
		input             dtos.VulnerabilityOutput
		expectError       bool
		expectedCompCount int
	}{
		{
			name: "Valid vulnerability output",
			input: dtos.VulnerabilityOutput{
				Components: []dtos.VulnerabilityComponentOutput{
					{
						Purl:            "pkg:npm/lodash@4.17.21",
						Version:         "4.17.21",
						Requirement:     "4.17.21",
						Vulnerabilities: []dtos.VulnerabilitiesOutput{},
					},
				},
			},
			expectError:       false,
			expectedCompCount: 1,
		},
		{
			name: "Empty vulnerability output",
			input: dtos.VulnerabilityOutput{
				Components: []dtos.VulnerabilityComponentOutput{},
			},
			expectError:       false,
			expectedCompCount: 0,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			componentsInfo, err := getComponentVulnerabilityInfo(tt.input)

			if tt.expectError && err == nil {
				t.Error("expected error but got none")
			}
			if !tt.expectError && err != nil {
				t.Errorf("unexpected error: %v", err)
			}
			if !tt.expectError && len(componentsInfo) != tt.expectedCompCount {
				t.Errorf("expected %d components but got %d", tt.expectedCompCount, len(componentsInfo))
			}
		})
	}
}
