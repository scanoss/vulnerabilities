// SPDX-License-Identifier: GPL-2.0-or-later
/*
 * Copyright (C) 2018-2025 SCANOSS.COM
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package adapters

import (
	"encoding/json"
	"errors"
	"fmt"
	common "github.com/scanoss/papi/api/commonv2"
	"scanoss.com/vulnerabilities/pkg/utils"

	pb "github.com/scanoss/papi/api/vulnerabilitiesv2"
	zlog "github.com/scanoss/zap-logging-helper/pkg/logger"
	"scanoss.com/vulnerabilities/pkg/dtos"
)

func sanitizeComponents(components []dtos.ComponentDTO) ([]dtos.ComponentDTO, []dtos.ComponentDTO) {
	var sanitized []dtos.ComponentDTO
	var invalid []dtos.ComponentDTO
	for _, component := range components {
		_, err := utils.PurlFromString(component.Purl)
		if err != nil {
			invalid = append(invalid, component)
			continue
		} else {
			sanitized = append(sanitized, component)
		}
	}
	return sanitized, invalid
}

func convertViaJSON(input interface{}, output interface{}, context string) error {
	data, err := json.Marshal(input)
	if err != nil {
		zlog.S.Errorf("Problem marshalling %s: %v", context, err)
		return fmt.Errorf("problem marshalling %s", context)
	}

	if len(data) == 0 {
		return errors.New("no input data supplied to parse")
	}

	zlog.S.Debugf("Parsed data: %v", string(data))

	err = json.Unmarshal(data, output)
	if err != nil {
		zlog.S.Errorf("Problem unmarshalling %s: %v", context, err)
		return fmt.Errorf("problem unmarshalling %s", context)
	}
	return nil
}

// FromVulnerabilityRequestToComponentDTO converts a Vulnerability Request structure into an internal Vulnerability Input struct.
func FromVulnerabilityRequestToComponentDTO(request *pb.VulnerabilityRequest) ([]dtos.ComponentDTO, []dtos.ComponentDTO,
	error) {
	if request == nil || len(request.Purls) == 0 {
		return nil, nil, errors.New("no input vulnerability data supplied to parse")
	}

	components := make([]dtos.ComponentDTO, 0, len(request.Purls))
	for _, purl := range request.Purls {
		components = append(components, dtos.ComponentDTO{Purl: purl.Purl, Requirement: purl.Requirement})
	}
	validComponents, invalidComponents := sanitizeComponents(components)
	return validComponents, invalidComponents, nil
}

// ConvertVulnerabilityOutput converts an internal Vulnerability Output structure into a Vulnerability Response struct.
func ConvertVulnerabilityOutput(output dtos.VulnerabilityOutput) (*pb.VulnerabilityResponse, error) {
	var vulnResp pb.VulnerabilityResponse
	if err := convertViaJSON(output, &vulnResp, "vulnerability output"); err != nil {
		return &pb.VulnerabilityResponse{}, err
	}
	return &vulnResp, nil
}

// ConvertCPEOutput converts an internal CPE Output structure into a Cpe Response struct.
func ConvertCPEOutput(cpeComponents []dtos.CpeComponentOutput) (*pb.CpeResponse, error) {
	var cpeResp pb.CpeResponse
	if len(cpeComponents) == 0 {
		return &pb.CpeResponse{Purls: make([]*pb.CpeResponse_Purls, 0)}, nil
	}

	purls := []*pb.CpeResponse_Purls{}
	for _, cpeComponent := range cpeComponents {
		purls = append(purls, &pb.CpeResponse_Purls{Purl: cpeComponent.Purl, Cpes: cpeComponent.Cpes})
	}
	cpeResp.Purls = purls
	return &cpeResp, nil
}

// FromComponentRequestToComponentDTO converts a Component Request structure into an internal Component DTO.
func FromComponentRequestToComponentDTO(request *common.ComponentRequest) (dtos.ComponentDTO, error) {
	var componentRequest dtos.ComponentDTO
	if err := convertViaJSON(request, &componentRequest, "component CPE request"); err != nil {
		return dtos.ComponentDTO{}, err
	}
	componentDTOs, _ := sanitizeComponents([]dtos.ComponentDTO{componentRequest})
	if componentDTOs == nil || len(componentDTOs) == 0 {
		return dtos.ComponentDTO{}, errors.New("no valid components supplied to parse")
	}
	return componentDTOs[0], nil
}

// FromComponentsRequestToComponentDTO converts a Components Request structure into internal Component DTOs.
func FromComponentsRequestToComponentDTO(request *common.ComponentsRequest) ([]dtos.ComponentDTO, []dtos.ComponentDTO, error) {
	var componentRequest []dtos.ComponentDTO
	if err := convertViaJSON(request, &componentRequest, "components CPE request"); err != nil {
		return nil, nil, err
	}
	validComponents, invalidComponents := sanitizeComponents(componentRequest)
	return validComponents, invalidComponents, nil
}

// ConvertToCPEComponentCPEInfo converts an internal CPE Output structure into Component CPE Info.
func ConvertToCPEComponentCPEInfo(output []dtos.CpeComponentOutput) ([]*pb.ComponentCpesInfo, error) {
	var resp []*pb.ComponentCpesInfo
	if err := convertViaJSON(output, &resp, "CPE component info"); err != nil {
		return nil, err
	}
	return resp, nil
}
