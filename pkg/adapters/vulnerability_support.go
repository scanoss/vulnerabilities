// SPDX-License-Identifier: GPL-2.0-or-later
/*
 * Copyright (C) 2018-2025 SCANOSS.COM
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package adapters

import (
	"encoding/json"
	"errors"
	"fmt"
	"strings"

	common "github.com/scanoss/papi/api/commonv2"
	pb "github.com/scanoss/papi/api/vulnerabilitiesv2"
	zlog "github.com/scanoss/zap-logging-helper/pkg/logger"
	"scanoss.com/vulnerabilities/pkg/dtos"
	"scanoss.com/vulnerabilities/pkg/utils"
)

func sanitizeComponents(components []dtos.ComponentDTO) ([]dtos.ComponentDTO, []dtos.ComponentDTO) {
	var sanitized []dtos.ComponentDTO
	var invalid []dtos.ComponentDTO
	for _, component := range components {
		_, err := utils.PurlFromString(component.Purl)
		if err != nil {
			invalid = append(invalid, component)
			continue
		} else {
			if component.Requirement == "" {
				purlParts := strings.Split(component.Purl, "@")
				if len(purlParts) == 2 {
					component.Purl = purlParts[0]
					component.Requirement = purlParts[1]
				}
			}
			sanitized = append(sanitized, component)
		}
	}
	return sanitized, invalid
}

func convertViaJSON(input interface{}, output interface{}, context string) error {
	data, err := json.Marshal(input)
	if err != nil {
		zlog.S.Errorf("Problem marshalling %s: %v", context, err)
		return fmt.Errorf("problem marshalling %s", context)
	}

	if len(data) == 0 {
		return errors.New("no input data supplied to parse")
	}

	err = json.Unmarshal(data, output)
	if err != nil {
		zlog.S.Errorf("Problem unmarshalling %s: %v", context, err)
		return fmt.Errorf("problem unmarshalling %s", context)
	}
	return nil
}

// FromVulnerabilityRequestToComponentDTO converts a Vulnerability Request structure into an internal Vulnerability Input struct.
//
//nolint:staticcheck // SA1019: keeping deprecated pb.VulnerabilityRequest for backward compatibility
func FromVulnerabilityRequestToComponentDTO(request *pb.VulnerabilityRequest) ([]dtos.ComponentDTO, []dtos.ComponentDTO,
	error) {
	if request == nil || len(request.Purls) == 0 {
		return nil, nil, errors.New("no input vulnerability data supplied to parse")
	}
	components := make([]dtos.ComponentDTO, 0, len(request.Purls))
	for _, purl := range request.Purls {
		// Strip semver operator from old requests to keep backward compatibility and avoid pickOneUrl method takes another version
		requirement := utils.StripSemverOperator(purl.Requirement)
		components = append(components, dtos.ComponentDTO{Purl: purl.Purl, Requirement: requirement})
	}
	validComponents, invalidComponents := sanitizeComponents(components)
	return validComponents, invalidComponents, nil
}

// FromVulnerabilityOutputToVulnerabilityResponse converts an internal Vulnerability Output structure into a Vulnerability Response struct.
//
//nolint:staticcheck // SA1019: keeping deprecated pb.VulnerabilityResponse for backward compatibility
func FromVulnerabilityOutputToVulnerabilityResponse(vulOutput dtos.VulnerabilityOutput) (*pb.VulnerabilityResponse, error) {
	purls := make([]*pb.VulnerabilityResponse_Purls, 0, len(vulOutput.Components))

	for _, c := range vulOutput.Components {
		var vul []*pb.Vulnerability
		if err := convertViaJSON(c.Vulnerabilities, &vul, "vulnerabilities"); err != nil {
			return nil, fmt.Errorf("error converting vulnerabilities for purl %s: %w", c.Purl, err)
		}
		purls = append(purls, &pb.VulnerabilityResponse_Purls{
			Purl:            c.Purl,
			Vulnerabilities: vul,
		})
	}
	return &pb.VulnerabilityResponse{Purls: purls}, nil //nolint:staticcheck // SA1019: keeping deprecated pb.VulnerabilityResponse for backward compatibility
}

// FromCpeComponentOutputTOCpeResponse converts an internal CPE Output structure into a Cpe Response struct.
//
//nolint:staticcheck // SA1019: keeping deprecated pb.CpeResponse for backward compatibility
func FromCpeComponentOutputTOCpeResponse(cpeComponents []dtos.CpeComponentOutput) (*pb.CpeResponse, error) {
	var cpeResp pb.CpeResponse //nolint:staticcheck // SA1019: keeping deprecated pb.CpeResponse for backward compatibility
	if len(cpeComponents) == 0 {
		return &pb.CpeResponse{Purls: make([]*pb.CpeResponse_Purls, 0)}, nil //nolint:staticcheck // SA1019: keeping deprecated pb.CpeResponse for backward compatibility
	}

	purls := []*pb.CpeResponse_Purls{}
	for _, cpeComponent := range cpeComponents {
		purls = append(purls, &pb.CpeResponse_Purls{Purl: cpeComponent.Purl, Cpes: cpeComponent.Cpes})
	}
	cpeResp.Purls = purls
	return &cpeResp, nil
}

// FromComponentsRequestToComponentDTO converts a Components Request structure into internal Component DTOs.
func FromComponentsRequestToComponentDTO(request *common.ComponentsRequest) ([]dtos.ComponentDTO, []dtos.ComponentDTO, error) {
	if request.Components == nil {
		return nil, nil, errors.New("'components' key is missing")
	}
	var componentRequest []dtos.ComponentDTO
	if err := convertViaJSON(request.Components, &componentRequest, "components request"); err != nil {
		return nil, nil, err
	}
	validComponents, invalidComponents := sanitizeComponents(componentRequest)
	return validComponents, invalidComponents, nil
}

// FromComponentRequestToComponentDTO converts a Component Request structure into an internal Component DTO.
func FromComponentRequestToComponentDTO(request *common.ComponentRequest) (dtos.ComponentDTO, error) {
	componentDTOs, _, err := FromComponentsRequestToComponentDTO(
		&common.ComponentsRequest{Components: []*common.ComponentRequest{request}})
	if err != nil {
		return dtos.ComponentDTO{}, err
	}
	if componentDTOs == nil {
		return dtos.ComponentDTO{}, errors.New("no valid components supplied to parse")
	}
	return componentDTOs[0], nil
}

func getComponentCPEInfo(input []dtos.CpeComponentOutput) ([]*pb.ComponentCpesInfo, error) {
	var componentsInfo []*pb.ComponentCpesInfo
	if err := convertViaJSON(input, &componentsInfo, "CPE component info"); err != nil {
		return nil, err
	}
	return componentsInfo, nil
}

// FromCpeComponentOutputToComponentCpesResponse converts an internal CPE Output structure into Component CPE Info.
func FromCpeComponentOutputToComponentCpesResponse(input []dtos.CpeComponentOutput) (*pb.ComponentCpesResponse, error) {
	componentsInfo, err := getComponentCPEInfo(input)
	if err != nil {
		return nil, err
	}
	if len(componentsInfo) == 0 {
		return nil, errors.New("no CPE component info supplied to parse")
	}
	response := &pb.ComponentCpesResponse{
		Component: componentsInfo[0],
	}
	return response, nil
}

// FromCpeComponentOutputToComponentCpesResponse converts an internal CPE Output structure into Component CPE Info.
func FromCpeComponentOutputToComponentsCpesResponse(input []dtos.CpeComponentOutput) (*pb.ComponentsCpesResponse, error) {
	componentsInfo, err := getComponentCPEInfo(input)
	if err != nil {
		return nil, err
	}
	response := pb.ComponentsCpesResponse{
		Components: componentsInfo,
	}
	return &response, nil
}

func getComponentVulnerabilityInfo(input dtos.VulnerabilityOutput) ([]*pb.ComponentVulnerabilityInfo, error) {
	var componentInfo []*pb.ComponentVulnerabilityInfo
	if err := convertViaJSON(input.Components, &componentInfo, "vulnerabilities"); err != nil {
		return nil, fmt.Errorf("error converting vulnerabilities %v: %w", input, err)
	}
	return componentInfo, nil
}

// FromVulnerabilityOutputToComponentVulnerabilityResponse converts an internal Vulnerability Output structure into a Vulnerability Response struct.
func FromVulnerabilityOutputToComponentVulnerabilityResponse(input dtos.VulnerabilityOutput) (*pb.ComponentVulnerabilityResponse, error) {
	componentsVulnerabilityInfo, err := getComponentVulnerabilityInfo(input)
	if err != nil {
		return nil, err
	}
	return &pb.ComponentVulnerabilityResponse{Component: componentsVulnerabilityInfo[0]}, nil
}

// FromVulnerabilityOutputToComponentsVulnerabilityResponse converts an internal Vulnerability Output structure into a Vulnerability Response struct.
func FromVulnerabilityOutputToComponentsVulnerabilityResponse(input dtos.VulnerabilityOutput) (*pb.ComponentsVulnerabilityResponse, error) {
	componentsVulnerabilityInfo, err := getComponentVulnerabilityInfo(input)
	if err != nil {
		return nil, err
	}
	return &pb.ComponentsVulnerabilityResponse{Components: componentsVulnerabilityInfo}, nil
}
