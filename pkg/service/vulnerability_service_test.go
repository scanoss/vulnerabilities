package service

import (
	"context"
	"encoding/json"
	"reflect"
	"testing"

	"github.com/jmoiron/sqlx"
	_ "github.com/mattn/go-sqlite3"
	common "github.com/scanoss/papi/api/commonv2"
	pb "github.com/scanoss/papi/api/vulnerabilitiesv2"
	zlog "github.com/scanoss/zap-logging-helper/pkg/logger"
	myconfig "scanoss.com/vulnerabilities/pkg/config"
	"scanoss.com/vulnerabilities/pkg/models"
)

func TestVulnerabilityServer_Echo(t *testing.T) {
	ctx := context.Background()
	err := zlog.NewSugaredDevLogger()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a sugared logger", err)
	}
	defer zlog.SyncZap()
	db, err := sqlx.Connect("sqlite3", ":memory:")
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer models.CloseDB(db)
	myConfig, err := myconfig.NewServerConfig(nil)
	if err != nil {
		t.Fatalf("failed to load Config: %v", err)
	}
	s := NewVulnerabilityServer(db, myConfig)

	type args struct {
		ctx context.Context
		req *common.EchoRequest
	}
	tests := []struct {
		name    string
		s       pb.VulnerabilitiesServer
		args    args
		want    *common.EchoResponse
		wantErr bool
	}{
		{
			name: "Echo",
			s:    s,
			args: args{
				ctx: ctx,
				req: &common.EchoRequest{Message: "Hello there!"},
			},
			want: &common.EchoResponse{Message: "Hello there!"},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := tt.s.Echo(tt.args.ctx, tt.args.req)
			if (err != nil) != tt.wantErr {
				t.Errorf("service.Echo() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if err == nil && !reflect.DeepEqual(got, tt.want) {
				t.Errorf("service.Echo() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestVulnerabilityServer_GetCpe(t *testing.T) {
	ctx := context.Background()
	err := zlog.NewSugaredDevLogger()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a sugared logger", err)
	}
	defer zlog.SyncZap()
	db, err := sqlx.Connect("sqlite3", "file::memory:?cache=shared")
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer models.CloseDB(db)
	conn, err := db.Connx(ctx)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer models.CloseConn(conn)
	err = models.LoadTestSQLData(db, ctx, conn)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when loading test data", err)
	}
	myConfig, err := myconfig.NewServerConfig(nil)
	if err != nil {
		t.Fatalf("failed to load Config: %v", err)
	}
	s := NewVulnerabilityServer(db, myConfig)

	var cpeRequestData = `
	{
		"purls": [
   	 		{
   	   			"purl": "pkg:github/tseliot/screen-resolution-extra@15.0.0"    
   	 		}
		]
	}`
	var cpeReq = pb.VulnerabilityRequest{}
	err = json.Unmarshal([]byte(cpeRequestData), &cpeReq)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when unmarshalling requestd", err)
	}

	var cpeRequestDataBad = `{"purls": []}`
	var cpeReqBad = pb.VulnerabilityRequest{}
	err = json.Unmarshal([]byte(cpeRequestDataBad), &cpeReqBad)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when unmarshalling requestd", err)
	}

	type args struct {
		ctx context.Context
		req *pb.VulnerabilityRequest
	}
	tests := []struct {
		name    string
		s       pb.VulnerabilitiesServer
		args    args
		want    *pb.CpeResponse
		wantErr bool
	}{
		{
			name: "Get CPEs Simple",
			s:    s,
			args: args{
				ctx: ctx,
				req: &cpeReq,
			},
			want: &pb.CpeResponse{Status: &common.StatusResponse{Status: common.StatusCode_SUCCESS, Message: "Success"}},
		},
		{
			name: "Get CPEs invalid request",
			s:    s,
			args: args{
				ctx: ctx,
				req: &cpeReqBad,
			},
			want:    &pb.CpeResponse{Status: &common.StatusResponse{Status: common.StatusCode_FAILED, Message: "Failed"}},
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var got *pb.CpeResponse
			got, err = tt.s.GetCpes(tt.args.ctx, tt.args.req)
			if (err != nil) != tt.wantErr {
				t.Errorf("service.GetCpe() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if err == nil && !reflect.DeepEqual(got.Status, tt.want.Status) {
				t.Errorf("service.GetCpe() = %v, want %v", got, tt.want)
			}
		})
	}

	// Close DB connection
	models.CloseDB(db)
	_, err = s.GetCpes(ctx, &cpeReq)
	if err == nil {
		t.Errorf("DB is closed, an error was expected, s.GetCpes()")
	}
}

func TestVulnerabilityServer_GetComponentCpe(t *testing.T) {
	ctx := context.Background()
	err := zlog.NewSugaredDevLogger()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a sugared logger", err)
	}
	defer zlog.SyncZap()
	db, err := sqlx.Connect("sqlite3", "file::memory:?cache=shared")
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer models.CloseDB(db)
	conn, err := db.Connx(ctx)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer models.CloseConn(conn)
	err = models.LoadTestSQLData(db, ctx, conn)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when loading test data", err)
	}
	myConfig, err := myconfig.NewServerConfig(nil)
	if err != nil {
		t.Fatalf("failed to load Config: %v", err)
	}
	s := NewVulnerabilityServer(db, myConfig)

	var cpeRequestData = `
	{
		"purl": "pkg:github/tseliot/screen-resolution-extra@15.0.0"
	}`
	var cpeReq = common.ComponentRequest{}
	err = json.Unmarshal([]byte(cpeRequestData), &cpeReq)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when unmarshalling requestd", err)
	}

	var cpeRequestDataBad = `{"purls": []}`
	var cpeReqBad = common.ComponentRequest{}
	err = json.Unmarshal([]byte(cpeRequestDataBad), &cpeReqBad)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when unmarshalling requestd", err)
	}

	var invalidComponentRequestData = `{
		"purl": "invalid-purl-format"
	}`
	var invalidComponentReq = common.ComponentRequest{}
	err = json.Unmarshal([]byte(invalidComponentRequestData), &invalidComponentReq)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when unmarshalling requestd", err)
	}

	type args struct {
		ctx context.Context
		req *common.ComponentRequest
	}
	tests := []struct {
		name    string
		s       pb.VulnerabilitiesServer
		args    args
		want    *pb.ComponentCpesResponse
		wantErr bool
	}{
		{
			name: "Get component CPES valid request",
			s:    s,
			args: args{
				ctx: ctx,
				req: &cpeReq,
			},
			want: &pb.ComponentCpesResponse{Status: &common.StatusResponse{Status: common.StatusCode_SUCCESS, Message: "Success"}},
		},
		{
			name: "Get Component CPES invalid request",
			s:    s,
			args: args{
				ctx: ctx,
				req: &cpeReqBad,
			},
			want:    &pb.ComponentCpesResponse{Status: &common.StatusResponse{Status: common.StatusCode_FAILED, Message: "Failed"}},
			wantErr: true,
		},
		{
			name: "Get Component CPES invalid component request data",
			s:    s,
			args: args{
				ctx: ctx,
				req: &invalidComponentReq,
			},
			want:    &pb.ComponentCpesResponse{Status: &common.StatusResponse{Status: common.StatusCode_FAILED, Message: "Problem parsing Vulnerability input data"}},
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var got *pb.ComponentCpesResponse
			got, err = tt.s.GetComponentCpes(tt.args.ctx, tt.args.req)
			if (err != nil) != tt.wantErr {
				t.Errorf("service.GetComponentCpes() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if err == nil && !reflect.DeepEqual(got.Status.Status, tt.want.Status.Status) {
				t.Errorf("service.GetCpe() = %v, want %v", got, tt.want)
			}
		})
	}

	// Test DB connection error path
	models.CloseDB(db)
	_, err = s.GetComponentCpes(ctx, &cpeReq)
	if err == nil {
		t.Errorf("DB is closed, an error was expected, s.GetComponentCpes()")
	}
}

func TestVulnerabilityServer_GetComponentsCpes(t *testing.T) {
	ctx := context.Background()
	err := zlog.NewSugaredDevLogger()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a sugared logger", err)
	}
	defer zlog.SyncZap()
	db, err := sqlx.Connect("sqlite3", "file::memory:?cache=shared")
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer models.CloseDB(db)
	conn, err := db.Connx(ctx)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer models.CloseConn(conn)
	err = models.LoadTestSQLData(db, ctx, conn)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when loading test data", err)
	}
	myConfig, err := myconfig.NewServerConfig(nil)
	if err != nil {
		t.Fatalf("failed to load Config: %v", err)
	}
	s := NewVulnerabilityServer(db, myConfig)

	var cpeRequestData = `{
		"components":[
			{
				"purl": "pkg:github/tseliot/screen-resolution-extra@15.0.0"
			}
		]
	}`
	var cpeReq = common.ComponentsRequest{}
	err = json.Unmarshal([]byte(cpeRequestData), &cpeReq)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when unmarshalling requestd", err)
	}

	var cpeRequestDataBad = `{"purls": []}`
	var cpeReqBad = common.ComponentsRequest{}
	err = json.Unmarshal([]byte(cpeRequestDataBad), &cpeReqBad)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when unmarshalling requestd", err)
	}

	var componentRequestInvalidComponents = `{
		"components": [
			{
				"purl": "pkg:github/tseliot/screen-resolution-extra@15.0.0"
			},
			{
				"purl": "p:github/tseliot/screen-resolution-extra@15.0.0"
			},
			{
				"purl": "pkg:github/tseliot/screen-resolution-extra",
				"requirement": "15.0.0"
			}
		]
	}`
	var requestInvalidComponents = common.ComponentsRequest{}
	err = json.Unmarshal([]byte(componentRequestInvalidComponents), &requestInvalidComponents)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when unmarshalling requestd", err)
	}

	type args struct {
		ctx context.Context
		req *common.ComponentsRequest
	}
	tests := []struct {
		name    string
		s       pb.VulnerabilitiesServer
		args    args
		want    *pb.ComponentsCpesResponse
		wantErr bool
	}{
		{
			name: "Get components CPEs succeeded",
			s:    s,
			args: args{
				ctx: ctx,
				req: &cpeReq,
			},
			want: &pb.ComponentsCpesResponse{Status: &common.StatusResponse{Status: common.StatusCode_SUCCESS, Message: "Success"}},
		},
		{
			name: "Get components CPEs failed",
			s:    s,
			args: args{
				ctx: ctx,
				req: &cpeReqBad,
			},
			want:    &pb.ComponentsCpesResponse{Status: &common.StatusResponse{Status: common.StatusCode_FAILED, Message: "Failed"}},
			wantErr: true,
		},
		{
			name: "Get Component CPES succeeded with warnings",
			s:    s,
			args: args{
				ctx: ctx,
				req: &requestInvalidComponents,
			},
			want:    &pb.ComponentsCpesResponse{Status: &common.StatusResponse{Status: common.StatusCode_SUCCEEDED_WITH_WARNINGS, Message: "Invalid components supplied"}},
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var got *pb.ComponentsCpesResponse
			got, err = tt.s.GetComponentsCpes(tt.args.ctx, tt.args.req)
			if (err != nil) != tt.wantErr {
				t.Errorf("service.GetComponentsCpes() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if err == nil && !reflect.DeepEqual(got.Status.Status, tt.want.Status.Status) {
				t.Errorf("service.GetComponentsCpes() = %v, want %v", got, tt.want)
			}
		})
	}
}

// ***************************** Vulnerabilities *****************************

func TestVulnerabilityServer_GetComponentsVulnerabilities(t *testing.T) {
	ctx := context.Background()
	err := zlog.NewSugaredDevLogger()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a sugared logger", err)
	}
	defer zlog.SyncZap()
	db, err := sqlx.Connect("sqlite3", "file::memory:?cache=shared")
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer models.CloseDB(db)
	conn, err := db.Connx(ctx)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer models.CloseConn(conn)
	err = models.LoadTestSQLData(db, ctx, conn)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when loading test data", err)
	}
	myConfig, err := myconfig.NewServerConfig(nil)
	if err != nil {
		t.Fatalf("failed to load Config: %v", err)
	}
	s := NewVulnerabilityServer(db, myConfig)

	var cpeRequestData = `{
		"components":[
			{
				"purl": "pkg:github/tseliot/screen-resolution-extra@15.0.0"
			}
		]
	}`
	var cpeReq = common.ComponentsRequest{}
	err = json.Unmarshal([]byte(cpeRequestData), &cpeReq)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when unmarshalling requestd", err)
	}

	var cpeRequestDataBad = `{"purls": []}`
	var cpeReqBad = common.ComponentsRequest{}
	err = json.Unmarshal([]byte(cpeRequestDataBad), &cpeReqBad)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when unmarshalling requestd", err)
	}

	var componentRequestInvalidComponents = `{
		"components": [
			{
				"purl": "pkg:github/tseliot/screen-resolution-extra@15.0.0"
			},
			{
				"purl": "p:github/tseliot/screen-resolution-extra@15.0.0"
			},
			{
				"purl": "pkg:github/tseliot/screen-resolution-extra",
				"requirement": "15.0.0"
			}
		]
	}`
	var requestInvalidComponents = common.ComponentsRequest{}
	err = json.Unmarshal([]byte(componentRequestInvalidComponents), &requestInvalidComponents)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when unmarshalling requestd", err)
	}

	type args struct {
		ctx context.Context
		req *common.ComponentsRequest
	}
	tests := []struct {
		name    string
		s       pb.VulnerabilitiesServer
		args    args
		want    *pb.ComponentsVulnerabilityResponse
		wantErr bool
	}{
		{
			name: "Get Components Vulnerabilities success",
			s:    s,
			args: args{
				ctx: ctx,
				req: &cpeReq,
			},
			want: &pb.ComponentsVulnerabilityResponse{Status: &common.StatusResponse{Status: common.StatusCode_SUCCESS, Message: "Success"}},
		},
		{
			name: "Get Components Vulnerabilities fail",
			s:    s,
			args: args{
				ctx: ctx,
				req: &cpeReqBad,
			},
			want:    &pb.ComponentsVulnerabilityResponse{Status: &common.StatusResponse{Status: common.StatusCode_FAILED, Message: "Failed"}},
			wantErr: true,
		},
		{
			name: "Get Components Vulnerabilities succeeded with warnings",
			s:    s,
			args: args{
				ctx: ctx,
				req: &requestInvalidComponents,
			},
			want:    &pb.ComponentsVulnerabilityResponse{Status: &common.StatusResponse{Status: common.StatusCode_SUCCEEDED_WITH_WARNINGS, Message: "Invalid components supplied"}},
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var got *pb.ComponentsVulnerabilityResponse
			got, err = tt.s.GetComponentsVulnerabilities(tt.args.ctx, tt.args.req)
			if (err != nil) != tt.wantErr {
				t.Errorf("service.GetComponentsCpes() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if err == nil && !reflect.DeepEqual(got.Status.Status, tt.want.Status.Status) {
				t.Errorf("service.GetComponentsCpes() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestVulnerabilityServer_GetComponentVulnerabilities(t *testing.T) {
	ctx := context.Background()
	err := zlog.NewSugaredDevLogger()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a sugared logger", err)
	}
	defer zlog.SyncZap()
	db, err := sqlx.Connect("sqlite3", "file::memory:?cache=shared")
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer models.CloseDB(db)
	conn, err := db.Connx(ctx)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer models.CloseConn(conn)
	err = models.LoadTestSQLData(db, ctx, conn)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when loading test data", err)
	}
	myConfig, err := myconfig.NewServerConfig(nil)
	if err != nil {
		t.Fatalf("failed to load Config: %v", err)
	}
	s := NewVulnerabilityServer(db, myConfig)

	var cpeRequestData = `{
		"purl": "pkg:github/tseliot/screen-resolution-extra@15.0.0"
	}`
	var cpeReq = common.ComponentRequest{}
	err = json.Unmarshal([]byte(cpeRequestData), &cpeReq)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when unmarshalling requestd", err)
	}

	var cpeRequestDataBad = `{"purls": []}`
	var cpeReqBad = common.ComponentRequest{}
	err = json.Unmarshal([]byte(cpeRequestDataBad), &cpeReqBad)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when unmarshalling requestd", err)
	}

	var invalidComponentRequestData = `{
		"purl": "invalid-purl-format"
	}`
	var invalidComponentReq = common.ComponentRequest{}
	err = json.Unmarshal([]byte(invalidComponentRequestData), &invalidComponentReq)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when unmarshalling requestd", err)
	}

	type args struct {
		ctx context.Context
		req *common.ComponentRequest
	}
	tests := []struct {
		name    string
		s       pb.VulnerabilitiesServer
		args    args
		want    *pb.ComponentVulnerabilityResponse
		wantErr bool
	}{
		{
			name: "Get Components Vulnerabilities success",
			s:    s,
			args: args{
				ctx: ctx,
				req: &cpeReq,
			},
			want: &pb.ComponentVulnerabilityResponse{Status: &common.StatusResponse{Status: common.StatusCode_SUCCESS, Message: "Success"}},
		},
		{
			name: "Get Components Vulnerabilities fail",
			s:    s,
			args: args{
				ctx: ctx,
				req: &cpeReqBad,
			},
			want:    &pb.ComponentVulnerabilityResponse{Status: &common.StatusResponse{Status: common.StatusCode_FAILED, Message: "Failed"}},
			wantErr: true,
		},
		{
			name: "Get Component Vulnerabilities invalid component request data",
			s:    s,
			args: args{
				ctx: ctx,
				req: &invalidComponentReq,
			},
			want:    &pb.ComponentVulnerabilityResponse{Status: &common.StatusResponse{Status: common.StatusCode_FAILED, Message: "Problem parsing Vulnerability input data"}},
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var got *pb.ComponentVulnerabilityResponse
			got, err = tt.s.GetComponentVulnerabilities(tt.args.ctx, tt.args.req)
			if (err != nil) != tt.wantErr {
				t.Errorf("service.GetComponentVulnerabilities() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if err == nil && !reflect.DeepEqual(got.Status.Status, tt.want.Status.Status) {
				t.Errorf("service.GetComponentVulnerabilities() = %v, want %v", got, tt.want)
			}
		})
	}

	// Test DB connection error path
	models.CloseDB(db)
	_, err = s.GetComponentVulnerabilities(ctx, &cpeReq)
	if err == nil {
		t.Errorf("DB is closed, an error was expected, s.GetComponentVulnerabilities()")
	}
}

func TestVulnerabilityServer_GetVulnerabilities(t *testing.T) {
	ctx := context.Background()
	err := zlog.NewSugaredDevLogger()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a sugared logger", err)
	}
	defer zlog.SyncZap()
	db, err := sqlx.Connect("sqlite3", "file::memory:?cache=shared")
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer models.CloseDB(db)
	conn, err := db.Connx(ctx)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer models.CloseConn(conn)
	err = models.LoadTestSQLData(db, ctx, conn)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when loading test data", err)
	}
	myConfig, err := myconfig.NewServerConfig(nil)
	if err != nil {
		t.Fatalf("failed to load Config: %v", err)
	}
	myConfig.Source.OSV.Enabled = false
	s := NewVulnerabilityServer(db, myConfig)

	var cpeRequestData = `{
		"purls":[
			{
				"purl": "pkg:github/tseliot/screen-resolution-extra"
			}
		]
	}`
	var successRequest = pb.VulnerabilityRequest{}
	err = json.Unmarshal([]byte(cpeRequestData), &successRequest)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when unmarshalling requestd", err)
	}

	var cpeRequestDataBad = `{"purls": []}`
	var cpeBadReq = pb.VulnerabilityRequest{}
	err = json.Unmarshal([]byte(cpeRequestDataBad), &cpeBadReq)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when unmarshalling requestd", err)
	}

	var componentRequestInvalidComponents = `{
		"purls": [
			{
				"purl": "pkg:github/tseliot/screen-resolution-extra"
			},
			{
				"purl": "p:github/tseliot/screen-resolution-extra"
			}
		]
	}`
	var requestInvalidComponents = pb.VulnerabilityRequest{}
	err = json.Unmarshal([]byte(componentRequestInvalidComponents), &requestInvalidComponents)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when unmarshalling requestd", err)
	}

	var invalidRequestData = `{
		"purls":[
			{
				"purl": "invalid-purl-format"
			}
		]
	}`
	var invalidReq = pb.VulnerabilityRequest{}
	err = json.Unmarshal([]byte(invalidRequestData), &invalidReq)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when unmarshalling requestd", err)
	}

	type args struct {
		ctx context.Context
		req *pb.VulnerabilityRequest
	}
	tests := []struct {
		name    string
		s       pb.VulnerabilitiesServer
		args    args
		want    *pb.VulnerabilityResponse
		wantErr bool
	}{
		{
			name: "Get Components Vulnerabilities success",
			s:    s,
			args: args{
				ctx: ctx,
				req: &successRequest,
			},
			want: &pb.VulnerabilityResponse{Status: &common.StatusResponse{Status: common.StatusCode_SUCCESS, Message: "Success"}},
		},
		{
			name: "Get Components Vulnerabilities fail",
			s:    s,
			args: args{
				ctx: ctx,
				req: &cpeBadReq,
			},
			want:    &pb.VulnerabilityResponse{Status: &common.StatusResponse{Status: common.StatusCode_FAILED, Message: "Failed"}},
			wantErr: true,
		},
		{
			name: "Get Components Vulnerabilities succeeded with warnings",
			s:    s,
			args: args{
				ctx: ctx,
				req: &requestInvalidComponents,
			},
			want:    &pb.VulnerabilityResponse{Status: &common.StatusResponse{Status: common.StatusCode_SUCCEEDED_WITH_WARNINGS, Message: "Invalid components supplied"}},
			wantErr: false,
		},
		{
			name: "Get Components Vulnerabilities invalid request data",
			s:    s,
			args: args{
				ctx: ctx,
				req: &invalidReq,
			},
			want:    &pb.VulnerabilityResponse{Status: &common.StatusResponse{Status: common.StatusCode_FAILED, Message: "Problem parsing Vulnerability input data"}},
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var got *pb.VulnerabilityResponse
			got, err = tt.s.GetVulnerabilities(tt.args.ctx, tt.args.req)
			if (err != nil) != tt.wantErr {
				t.Errorf("service.GetVulnerabilities() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if err == nil && !reflect.DeepEqual(got.Status.Status, tt.want.Status.Status) {
				t.Errorf("service.GetVulnerabilities() = %v, want %v", got, tt.want)
			}
		})
	}

	// Test DB connection error path - use a separate DB instance
	dbClosed, err := sqlx.Connect("sqlite3", "file::memory:?cache=shared")
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	sWithClosedDB := NewVulnerabilityServer(dbClosed, myConfig)
	models.CloseDB(dbClosed)
	_, err = sWithClosedDB.GetVulnerabilities(ctx, &cpeBadReq)
	if err == nil {
		t.Errorf("DB is closed, an error was expected, s.GetVulnerabilities()")
	}
}

func TestVulnerabilityServer_CloseDBConnection(t *testing.T) {
	ctx := context.Background()
	err := zlog.NewSugaredDevLogger()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a sugared logger", err)
	}
	defer zlog.SyncZap()
	db, err := sqlx.Connect("sqlite3", "file::memory:?cache=shared")
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer models.CloseDB(db)
	myConfig, err := myconfig.NewServerConfig(nil)
	if err != nil {
		t.Fatalf("failed to load Config: %v", err)
	}
	vs := &vulnerabilityServer{db: db, config: myConfig}

	// Test normal connection close
	conn, err := db.Connx(ctx)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a database connection", err)
	}
	vs.closeDBConnection(ctx, conn)

	// Test closing already closed connection to trigger warning path
	alreadyClosedConn, err := db.Connx(ctx)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a database connection", err)
	}
	err = alreadyClosedConn.Close() // Close it first
	if err != nil {
		t.Fatalf("an error '%s' was not expected when closing connection", err)
	}
	// Now close it again through the function - this should trigger the warning path
	vs.closeDBConnection(ctx, alreadyClosedConn)
}
