package service

import (
	"context"
	"encoding/json"
	"reflect"
	"testing"

	"github.com/jmoiron/sqlx"
	_ "github.com/mattn/go-sqlite3"
	common "github.com/scanoss/papi/api/commonv2"
	pb "github.com/scanoss/papi/api/vulnerabilitiesv2"
	myconfig "scanoss.com/vulnerabilities/pkg/config"
	zlog "scanoss.com/vulnerabilities/pkg/logger"
	"scanoss.com/vulnerabilities/pkg/models"
)

func TestVulnerabilityServer_Echo(t *testing.T) {
	ctx := context.Background()
	err := zlog.NewSugaredDevLogger()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a sugared logger", err)
	}
	defer zlog.SyncZap()
	db, err := sqlx.Connect("sqlite3", ":memory:")
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer models.CloseDB(db)
	myConfig, err := myconfig.NewServerConfig(nil)
	if err != nil {
		t.Fatalf("failed to load Config: %v", err)
	}
	s := NewVulnerabilityServer(db, myConfig)

	type args struct {
		ctx context.Context
		req *common.EchoRequest
	}
	tests := []struct {
		name    string
		s       pb.VulnerabilitiesServer
		args    args
		want    *common.EchoResponse
		wantErr bool
	}{
		{
			name: "Echo",
			s:    s,
			args: args{
				ctx: ctx,
				req: &common.EchoRequest{Message: "Hello there!"},
			},
			want: &common.EchoResponse{Message: "Hello there!"},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := tt.s.Echo(tt.args.ctx, tt.args.req)
			if (err != nil) != tt.wantErr {
				t.Errorf("service.Echo() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if err == nil && !reflect.DeepEqual(got, tt.want) {
				t.Errorf("service.Echo() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestVulneravilityServer_GetCpe(t *testing.T) {
	ctx := context.Background()
	err := zlog.NewSugaredDevLogger()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a sugared logger", err)
	}
	defer zlog.SyncZap()
	db, err := sqlx.Connect("sqlite3", ":memory:")
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer models.CloseDB(db)
	err = models.LoadTestSQLData(db, nil, nil)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when loading test data", err)
	}
	myConfig, err := myconfig.NewServerConfig(nil)
	if err != nil {
		t.Fatalf("failed to load Config: %v", err)
	}
	s := NewVulnerabilityServer(db, myConfig)

	var cpeRequestData = `
	{
		"purls": [
   	 		{
   	   			"purl": "pkg:github/tseliot/screen-resolution-extra@15.0.0"    
   	 		}
		]
	}`
	var cpeReq = pb.VulnerabilityRequest{}
	err = json.Unmarshal([]byte(cpeRequestData), &cpeReq)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when unmarshalling requestd", err)
	}

	var cpeRequestDataBad = `{"purls": []}`
	var cpeReqBad = pb.VulnerabilityRequest{}
	err = json.Unmarshal([]byte(cpeRequestDataBad), &cpeReqBad)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when unmarshalling requestd", err)
	}

	type args struct {
		ctx context.Context
		req *pb.VulnerabilityRequest
	}
	tests := []struct {
		name    string
		s       pb.VulnerabilitiesServer
		args    args
		want    *pb.CpeResponse
		wantErr bool
	}{
		{
			name: "Get cpe Simple",
			s:    s,
			args: args{
				ctx: ctx,
				req: &cpeReq,
			},
			want: &pb.CpeResponse{Status: &common.StatusResponse{Status: common.StatusCode_SUCCESS, Message: "Success"}},
		},
		{
			name: "Get vuln Simple False",
			s:    s,
			args: args{
				ctx: ctx,
				req: &cpeReqBad,
			},
			want:    &pb.CpeResponse{Status: &common.StatusResponse{Status: common.StatusCode_FAILED, Message: "Failed"}},
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var got *pb.CpeResponse
			got, err = tt.s.GetCpes(tt.args.ctx, tt.args.req)
			if (err != nil) != tt.wantErr {
				t.Errorf("service.GetCpe() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if err == nil && !reflect.DeepEqual(got.Status, tt.want.Status) {
				t.Errorf("service.GetCpe() = %v, want %v", got, tt.want)
			}
		})
	}

	// Close DB connection
	models.CloseDB(db)
	_, err = s.GetCpes(ctx, &cpeReq)
	if err == nil {
		t.Errorf("DB is closed, an error was expected, s.GetCpes()")
	}
}

//TODO: Convert PostgreSQL-specific syntax to ANSI SQL for cross-database compatibility
/*
func TestVulneravilityServer_GetVulneravility(t *testing.T) {
	ctx := context.Background()
	err := zlog.NewSugaredDevLogger()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a sugared logger", err)
	}
	defer zlog.SyncZap()
	db, err := sqlx.Connect("sqlite3", ":memory:")
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer models.CloseDB(db)
	err = models.LoadTestSQLData(db, nil, nil)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when loading test data", err)
	}
	myConfig, err := myconfig.NewServerConfig(nil)
	if err != nil {
		t.Fatalf("failed to load Config: %v", err)
	}
	s := NewVulnerabilityServer(db, myConfig)

	var vulnRequestData = `
	{
		"purls": [
   	 		{
   	   			"purl": "pkg:github/tseliot/screen-resolution-extra",
				"requirement": "15.0.0"
   	 		}
		]
	}`
	var vulnReq = pb.VulnerabilityRequest{}
	err = json.Unmarshal([]byte(vulnRequestData), &vulnReq)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when unmarshalling requestd", err)
	}

	//Broken purl
	var vulnRequestDataBad = `
		{
		  "purls": [
			{
			  "purl": "pkg:github/"
			}
		  ]
		}
`
	var vulnReqBad = pb.VulnerabilityRequest{}
	err = json.Unmarshal([]byte(vulnRequestDataBad), &vulnReqBad)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when unmarshalling requestd", err)
	}

	type args struct {
		ctx context.Context
		req *pb.VulnerabilityRequest
	}
	tests := []struct {
		name    string
		s       pb.VulnerabilitiesServer
		args    args
		want    *pb.VulnerabilityResponse
		wantErr bool
	}{
		{
			name: "Get cpe Simple",
			s:    s,
			args: args{
				ctx: ctx,
				req: &vulnReq,
			},
			want: &pb.VulnerabilityResponse{Status: &common.StatusResponse{Status: common.StatusCode_SUCCESS, Message: "Success"}},
		},
		{
			name: "Get cpes Simple False",
			s:    s,
			args: args{
				ctx: ctx,
				req: &vulnReqBad,
			},
			want:    &pb.VulnerabilityResponse{Status: &common.StatusResponse{Status: common.StatusCode_FAILED, Message: "Failed"}},
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := tt.s.GetVulnerabilities(tt.args.ctx, tt.args.req)
			if (err != nil) != tt.wantErr {
				t.Errorf("service.GetVulnerabilities() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if err == nil && !reflect.DeepEqual(got.Status, tt.want.Status) {
				t.Errorf("service.GetVulnerabilities() = %v, want %v", got, tt.want)
			}
		})
	}

	//Close DB connection
	models.CloseDB(db)
	_, err = s.GetVulnerabilities(ctx, &vulnReq)
	if err == nil {
		t.Errorf("DB is closed, an error was expected, s.GetVulnerabilities()")
	}

}*/
